"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var color_1 = require("tns-core-modules/color");
var calendar_common_1 = require("./calendar-common");
var calendarTypes = ["Local", "CalDAV", "Exchange", "Subscription", "Birthday", "Mail"];
var frequencies = ["daily", "weekly", "monthly", "yearly"];
calendar_common_1.Calendar._eventStore = null;
calendar_common_1.Calendar._getRecurrenceFrequency = function (frequency) {
    if (frequency === "daily") {
        return 0;
    }
    else if (frequency === "weekly") {
        return 1;
    }
    else if (frequency === "monthly") {
        return 2;
    }
    else if (frequency === "yearly") {
        return 3;
    }
    else {
        return null;
    }
};
calendar_common_1.Calendar._invokeFunctionOnEventStore = function (onInitComplete, reject) {
    if (calendar_common_1.Calendar._eventStore !== null) {
        onInitComplete();
        return;
    }
    var eventStoreCandidate = EKEventStore.new();
    eventStoreCandidate.requestAccessToEntityTypeCompletion(0, function (granted, error) {
        if (granted) {
            calendar_common_1.Calendar._eventStore = eventStoreCandidate;
            onInitComplete();
        }
        else {
            reject("Please allow access to the Calendar and try again.");
        }
    });
};
calendar_common_1.Calendar._hasPermission = function () {
    return 3 === EKEventStore.authorizationStatusForEntityType(0);
};
function hasPermission(arg) {
    return new Promise(function (resolve, reject) {
        try {
            resolve(calendar_common_1.Calendar._hasPermission());
        }
        catch (ex) {
            console.log("Error in Calendar.hasPermission: " + ex);
            reject(ex);
        }
    });
}
exports.hasPermission = hasPermission;
function requestPermission(arg) {
    return new Promise(function (resolve, reject) {
        try {
            calendar_common_1.Calendar._invokeFunctionOnEventStore(resolve, reject);
        }
        catch (ex) {
            console.log("Error in Calendar.requestPermission: " + ex);
            reject(ex);
        }
    });
}
exports.requestPermission = requestPermission;
calendar_common_1.Calendar._findCalendars = function (filterByName) {
    var calendars = calendar_common_1.Calendar._eventStore.calendarsForEntityType(0);
    var result = [];
    for (var i = 0, j = calendars.count; i < j; i++) {
        var calendar = calendars.objectAtIndex(i);
        if (!filterByName || filterByName === calendar.title) {
            result.push(calendar);
        }
    }
    return result;
};
calendar_common_1.Calendar._findEKEvents = function (arg, calendars) {
    var datedEvents = calendar_common_1.Calendar._eventStore.eventsMatchingPredicate(calendar_common_1.Calendar._eventStore.predicateForEventsWithStartDateEndDateCalendars(arg.startDate, arg.endDate, calendars));
    if (datedEvents === null) {
        return null;
    }
    var predicates = [];
    if (arg.title !== undefined) {
        predicates.push("title contains[c] '" + arg.title.replace(/'/g, "\\'") + "'");
    }
    if (arg.location !== undefined) {
        predicates.push("location contains[c] '" + arg.location.replace(/'/g, "\\'") + "'");
    }
    if (arg.notes !== undefined) {
        predicates.push("notes contains[c] '" + arg.notes.replace(/'/g, "\\'") + "'");
    }
    if (predicates.length > 0) {
        var predicate = predicates.join(' AND ');
        return datedEvents.filteredArrayUsingPredicate(NSPredicate.predicateWithFormatArgumentArray(predicate, null));
    }
    else {
        return datedEvents;
    }
};
calendar_common_1.Calendar._findEKSource = function () {
    var eKSource, eKSources = calendar_common_1.Calendar._eventStore.sources;
    for (var i = 0, j = eKSources.count; i < j; i++) {
        eKSource = eKSources.objectAtIndex(i);
        if (eKSource.sourceType === 2 && eKSource.title === "iCloud") {
            return eKSource;
        }
    }
    for (var k = 0, l = eKSources.count; k < l; k++) {
        eKSource = eKSources.objectAtIndex(k);
        if (eKSource.sourceType === 0) {
            return eKSource;
        }
    }
    return null;
};
function listCalendars(arg) {
    return new Promise(function (resolve, reject) {
        try {
            var onPermissionGranted = function () {
                var result = [];
                var ekCalendars = calendar_common_1.Calendar._findCalendars();
                for (var c in ekCalendars) {
                    var ekCalendar = ekCalendars[c];
                    result.push({
                        id: ekCalendar.calendarIdentifier,
                        name: ekCalendar.title,
                        displayName: ekCalendar.title,
                        type: calendarTypes[ekCalendar.type]
                    });
                }
                resolve(result);
            };
            calendar_common_1.Calendar._invokeFunctionOnEventStore(onPermissionGranted, reject);
        }
        catch (ex) {
            console.log("Error in Calendar.listCalendars: " + ex);
            reject(ex);
        }
    });
}
exports.listCalendars = listCalendars;
calendar_common_1.Calendar._ekEventToJSEvent = function (ekEvent) {
    var attendeeTypes = ["Unknown", "Person", "Room", "Resource", "Group"];
    var attendeeRoles = ["Unknown", "Required", "Optional", "Chair", "Non Participant"];
    var attendeeStatuses = ["Unknown", "Pending", "Accepted", "Declined", "Tentative", "Delegated", "Completed", "In Process"];
    var ekCalendar = ekEvent.calendar;
    var attendees = [];
    if (ekEvent.attendees !== null) {
        for (var k = 0, l = ekEvent.attendees.count; k < l; k++) {
            var ekParticipant = ekEvent.attendees.objectAtIndex(k);
            attendees.push({
                name: ekParticipant.name,
                email: ekParticipant.URL.resourceSpecifier,
                url: ekParticipant.URL,
                status: attendeeStatuses[ekParticipant.participantStatus],
                role: attendeeRoles[ekParticipant.participantRole],
                type: attendeeTypes[ekParticipant.participantType]
            });
        }
    }
    var reminders = [];
    if (ekEvent.alarms !== null) {
        for (var k = 0, l = ekEvent.alarms.count; k < l; k++) {
            var ekAlarm = ekEvent.alarms.objectAtIndex(k);
            reminders.push({
                minutes: -(ekAlarm.relativeOffset / 60)
            });
        }
    }
    var recurrence;
    if (ekEvent.recurrenceRules !== null) {
        var ekRecurrenceRule = ekEvent.recurrenceRules.objectAtIndex(0);
        recurrence = {
            frequency: frequencies[ekRecurrenceRule.frequency],
            interval: ekRecurrenceRule.interval,
            endDate: ekRecurrenceRule.recurrenceEnd ? ekRecurrenceRule.recurrenceEnd.endDate : null,
            count: ekRecurrenceRule.recurrenceEnd ? ekRecurrenceRule.recurrenceEnd.occurrenceCount : undefined
        };
    }
    return {
        id: ekEvent.calendarItemIdentifier,
        title: ekEvent.title,
        startDate: ekEvent.startDate,
        endDate: ekEvent.endDate,
        location: ekEvent.location,
        notes: ekEvent.notes,
        url: ekEvent.URL ? ekEvent.URL.absoluteString : null,
        allDay: ekEvent.allDay,
        attendees: attendees,
        reminders: reminders,
        recurrence: recurrence,
        calendar: {
            id: ekCalendar.calendarIdentifier,
            name: ekCalendar.title,
            displayName: ekCalendar.title,
            type: calendarTypes[ekCalendar.type]
        }
    };
};
function findEvents(arg) {
    return new Promise(function (resolve, reject) {
        try {
            var settings_1 = calendar_common_1.Calendar.merge(arg, calendar_common_1.Calendar.defaults);
            if (!settings_1.startDate || !settings_1.endDate) {
                reject("startDate and endDate are mandatory");
                return;
            }
            var onPermissionGranted = function () {
                var calendars;
                if (settings_1.calendar.name === null) {
                    calendars = calendar_common_1.Calendar._eventStore.calendarsForEntityType(0);
                    if (calendars.count === 0) {
                        reject("No default calendar found. Is access to the Calendar blocked for this app?");
                        return;
                    }
                }
                else {
                    var cals = calendar_common_1.Calendar._findCalendars(settings_1.calendar.name);
                    var calendar = void 0;
                    if (cals.length > 0) {
                        calendar = cals[0];
                    }
                    if (calendar === null) {
                        reject("Could not find calendar");
                        return;
                    }
                    else {
                        calendars = [calendar];
                    }
                }
                if (settings_1.id) {
                    var eKCalendarItem = calendar_common_1.Calendar._eventStore.calendarItemWithIdentifier(settings_1.id);
                    if (eKCalendarItem !== null) {
                        resolve([calendar_common_1.Calendar._ekEventToJSEvent(eKCalendarItem)]);
                        return;
                    }
                }
                var events = [];
                var matchingEvents = calendar_common_1.Calendar._findEKEvents(settings_1, calendars);
                if (matchingEvents !== null) {
                    for (var i = 0, j = matchingEvents.count; i < j; i++) {
                        events.push(calendar_common_1.Calendar._ekEventToJSEvent(matchingEvents.objectAtIndex(i)));
                    }
                }
                resolve(events);
            };
            calendar_common_1.Calendar._invokeFunctionOnEventStore(onPermissionGranted, reject);
        }
        catch (ex) {
            console.log("Error in Calendar.findEvent: " + ex);
            reject(ex);
        }
    });
}
exports.findEvents = findEvents;
function createEvent(arg) {
    return new Promise(function (resolve, reject) {
        try {
            var settings_2 = calendar_common_1.Calendar.merge(arg, calendar_common_1.Calendar.defaults);
            if (!settings_2.startDate || !settings_2.endDate) {
                reject("startDate and endDate are mandatory");
                return;
            }
            if (!arg || !arg.reminders) {
                settings_2.reminders = null;
            }
            var onPermissionGranted = function () {
                var eKEvent = EKEvent.eventWithEventStore(calendar_common_1.Calendar._eventStore);
                eKEvent.title = settings_2.title;
                eKEvent.location = settings_2.location;
                eKEvent.notes = settings_2.notes;
                eKEvent.startDate = settings_2.startDate;
                eKEvent.endDate = settings_2.endDate;
                if (settings_2.url) {
                    eKEvent.URL = NSURL.URLWithString(settings_2.url);
                }
                var duration = settings_2.endDate.getTime() - settings_2.startDate.getTime();
                var moduloDay = duration % (1000 * 60 * 60 * 24);
                if (moduloDay === 0) {
                    eKEvent.allDay = true;
                }
                var calendar = null;
                if (settings_2.calendar.name === null) {
                    calendar = calendar_common_1.Calendar._eventStore.defaultCalendarForNewEvents;
                    if (calendar === null) {
                        reject("No default calendar found. Is access to the Calendar blocked for this app?");
                        return;
                    }
                }
                else {
                    var cals = calendar_common_1.Calendar._findCalendars(settings_2.calendar.name);
                    if (cals.length > 0) {
                        calendar = cals[0];
                    }
                    if (calendar === null) {
                        calendar = EKCalendar.calendarForEntityTypeEventStore(0, calendar_common_1.Calendar._eventStore);
                        calendar.title = settings_2.calendar.name;
                        if (settings_2.calendar.color && color_1.Color.isValid(settings_2.calendar.color)) {
                            calendar.CGColor = new color_1.Color(settings_2.calendar.color).ios;
                        }
                        calendar.source = calendar_common_1.Calendar._findEKSource();
                        calendar_common_1.Calendar._eventStore.saveCalendarCommitError(calendar, true, null);
                    }
                }
                eKEvent.calendar = calendar;
                if (settings_2.reminders && settings_2.reminders.first !== null) {
                    eKEvent.addAlarm(EKAlarm.alarmWithRelativeOffset(-1 * settings_2.reminders.first * 60));
                }
                if (settings_2.reminders && settings_2.reminders.second !== null) {
                    eKEvent.addAlarm(EKAlarm.alarmWithRelativeOffset(-1 * settings_2.reminders.second * 60));
                }
                if (settings_2.recurrence.frequency !== null) {
                    var frequency = calendar_common_1.Calendar._getRecurrenceFrequency(settings_2.recurrence.frequency);
                    var eKRecurrenceRule = EKRecurrenceRule.alloc().initRecurrenceWithFrequencyIntervalEnd(frequency, settings_2.recurrence.interval, null);
                    if (arg.recurrence.endDate !== null) {
                        eKRecurrenceRule.recurrenceEnd = EKRecurrenceEnd.recurrenceEndWithEndDate(arg.recurrence.endDate);
                    }
                    eKEvent.addRecurrenceRule(eKRecurrenceRule);
                }
                var error = null;
                calendar_common_1.Calendar._eventStore.saveEventSpanError(eKEvent, "EKSpanThisEvent", error);
                if (error === null) {
                    resolve(eKEvent.calendarItemIdentifier);
                }
                else {
                    reject(error);
                }
            };
            calendar_common_1.Calendar._invokeFunctionOnEventStore(onPermissionGranted, reject);
        }
        catch (ex) {
            console.log("Error in Calendar.createEvent: " + ex);
            reject(ex);
        }
    });
}
exports.createEvent = createEvent;
function deleteEvents(arg) {
    return new Promise(function (resolve, reject) {
        try {
            var settings_3 = calendar_common_1.Calendar.merge(arg, calendar_common_1.Calendar.defaults);
            if (!settings_3.startDate || !settings_3.endDate) {
                reject("startDate and endDate are mandatory");
                return;
            }
            var onPermissionGranted = function () {
                var calendars;
                if (settings_3.calendar.name === null) {
                    calendars = calendar_common_1.Calendar._eventStore.calendarsForEntityType(0);
                    if (calendars.count === 0) {
                        reject("No default calendar found. Is access to the Calendar blocked for this app?");
                        return;
                    }
                }
                else {
                    var cals = calendar_common_1.Calendar._findCalendars(settings_3.calendar.name);
                    var calendar = void 0;
                    if (cals.length > 0) {
                        calendar = cals[0];
                    }
                    if (calendar === null) {
                        reject("Could not find calendar");
                        return;
                    }
                    else {
                        calendars = [calendar];
                    }
                }
                if (settings_3.id) {
                    var eKCalendarItem = calendar_common_1.Calendar._eventStore.calendarItemWithIdentifier(settings_3.id);
                    if (eKCalendarItem !== null) {
                        calendar_common_1.Calendar._eventStore.removeEventSpanError(eKCalendarItem, 0, null);
                        resolve([settings_3.id]);
                    }
                    else {
                        resolve([]);
                    }
                    return;
                }
                var matchingEvents = calendar_common_1.Calendar._findEKEvents(settings_3, calendars);
                var deletedEventIds = [];
                if (matchingEvents !== null) {
                    for (var i = 0, j = matchingEvents.count; i < j; i++) {
                        var ekEvent = matchingEvents.objectAtIndex(i);
                        deletedEventIds.push(ekEvent.calendarItemIdentifier);
                        calendar_common_1.Calendar._eventStore.removeEventSpanError(ekEvent, 0, null);
                    }
                }
                resolve(deletedEventIds);
            };
            calendar_common_1.Calendar._invokeFunctionOnEventStore(onPermissionGranted, reject);
        }
        catch (ex) {
            console.log("Error in Calendar.deleteEvent: " + ex);
            reject(ex);
        }
    });
}
exports.deleteEvents = deleteEvents;
function deleteCalendar(arg) {
    return new Promise(function (resolve, reject) {
        try {
            if (!arg.name) {
                reject("name is mandatory");
                return;
            }
            var onPermissionGranted = function () {
                var calendars = calendar_common_1.Calendar._findCalendars(arg.name);
                var deletedCalId = null;
                if (calendars.length > 0) {
                    for (var c in calendars) {
                        var calendar = calendars[c];
                        calendar_common_1.Calendar._eventStore.removeCalendarCommitError(calendar, true, null);
                        deletedCalId = calendar.calendarIdentifier;
                    }
                }
                resolve(deletedCalId);
            };
            calendar_common_1.Calendar._invokeFunctionOnEventStore(onPermissionGranted, reject);
        }
        catch (ex) {
            console.log("Error in Calendar.deleteCalendar: " + ex);
            reject(ex);
        }
    });
}
exports.deleteCalendar = deleteCalendar;
